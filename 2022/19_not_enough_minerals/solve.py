#!/usr/bin/env python3
import sys
import pprint
import re
from collections import deque


def debug(*args, pretty=False, **kwargs):
    "print() to stderr for debuggin purposes"
    if pretty:
        pprint.pprint(*args, **kwargs, stream=sys.stderr)
    else:
        print(
            *args,
            **kwargs,
            file=sys.stderr,
        )

####


def solve(cost_ore_ore, cost_ore_clay, cost_ore_obsidian, cost_clay_obsidian, cost_ore_geode, cost_obsidian_geode, time):
    # ore, clay, obsidian, geodes, orebots, claybots, obsidianbots, geodebots, time
    initial_state = (0, 0, 0, 0, 1, 0, 0, 0, time)
    q = deque([initial_state])
    seen = set()
    best = 0

    while q:
        state = o, c, ob, g, b1, b2, b3, b4, t = q.popleft()
        best = max(best, g)

        if t == 0:
            continue

        # do not consider more robots than what can be spent in a round and material
        # since robots generate 1 material per round

        max_ore = max([cost_ore_ore, cost_ore_clay,
                      cost_ore_obsidian, cost_ore_geode])

        b1 = min(b1, max_ore)
        b2 = min(b2, cost_clay_obsidian)
        b3 + min(b3, cost_obsidian_geode)
        # always need more geodes!

        # discard material that cannot be spent
        # max ore that can be spent in time
        # subtract ore that will be generated by bots

        o = min(o, max_ore*t - b1*(t-1))
        c = min(c, cost_clay_obsidian*t - b2*(t-1))
        ob = min(ob, cost_obsidian_geode*t - b3*(t-1))
        # always need more geodes!

        state = (o, c, ob, g, b1, b2, b3, b4, t)
        if state in seen:
            continue
        seen.add(state)

        # do nothing := spend 1 time, existing bots generate minerals
        q.append((o+b1, c+b2, ob+b3, g+b4, b1, b2, b3, b4, t-1))

        assert all(x >= 0 for x in [o, c, ob, g]), state
        # check minerals do decide of we can build a bot
        if o >= cost_ore_ore:
            # build ore bot := gain bot, spend resources, spend 1 time, existing bots generate minerals
            q.append((o+b1-cost_ore_ore, c+b2, ob +
                     b3, g+b4, b1+1, b2, b3, b4, t-1))
        if o >= cost_ore_clay:
            # build clay bot := gain bot, spend resources, spend 1 time, existing bots generate minerals
            q.append((o+b1-cost_ore_clay, c+b2, ob +
                     b3, g+b4, b1, b2+1, b3, b4, t-1))
        if o >= cost_ore_obsidian and c >= cost_clay_obsidian:
            # build obsidian bot := gain bot, spend resources, spend 1 time, existing bots generate minerals
            q.append((o+b1-cost_ore_obsidian, c+b2-cost_clay_obsidian,
                     ob+b3, g+b4, b1, b2, b3+1, b4, t-1))
        if o >= cost_ore_geode and ob >= cost_obsidian_geode:
            # build geode bot := gain bot, spend resources, spend 1 time, existing bots generate minerals
            q.append((o+b1-cost_ore_geode, c+b2, ob+b3 -
                     cost_obsidian_geode, g+b4, b1, b2, b3, b4+1, t-1))

    return best


p1 = 0
p2 = 1
for i, line in enumerate(open(0)):
    id, ore_cost_ore, clay_cost_ore, obsidian_cost_ore, obsidian_cost_clay, geode_cost_ore, geode_cost_obsidian = map(
        int, re.findall(r"\d+", line))

    debug((id, ore_cost_ore, clay_cost_ore, obsidian_cost_ore,
           obsidian_cost_clay,  geode_cost_ore, geode_cost_obsidian))
    # [ore, clay, obsidian, geode]
    res = solve(ore_cost_ore, clay_cost_ore, obsidian_cost_ore,
                obsidian_cost_clay,  geode_cost_ore, geode_cost_obsidian, 24)
    debug(res)
    p1 += res * id

    if i < 3:
        p2 *= solve(ore_cost_ore, clay_cost_ore, obsidian_cost_ore,
                    obsidian_cost_clay,  geode_cost_ore, geode_cost_obsidian, 32)

print(f"p1: {p1}")
print(f"p2: {p2}")
